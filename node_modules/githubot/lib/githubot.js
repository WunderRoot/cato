(function() {
  var Github, async, func, github, http, method, querystring, version, _ref, _ref2;
  var _this = this;

  http = require("scoped-http-client");

  async = require("async");

  querystring = require("querystring");

  version = require("../package.json")["version"];

  Github = (function() {

    function Github(logger, options) {
      var _this = this;
      this.logger = logger;
      this.options = options;
      this.requestQueue = async.queue(function(task, cb) {
        return task.run(cb);
      }, this._opt("concurrentRequests"));
    }

    Github.prototype.withOptions = function(specialOptions) {
      var g, k, newOpts, v, _ref;
      newOpts = {};
      _ref = this.options;
      for (k in _ref) {
        v = _ref[k];
        newOpts[k] = v;
      }
      for (k in specialOptions) {
        v = specialOptions[k];
        newOpts[k] = v;
      }
      g = new this.constructor(this.logger, newOpts);
      g.requestQueue = this.requestQueue;
      return g;
    };

    Github.prototype.qualified_repo = function(repo) {
      var user;
      if (repo == null) {
        if ((repo = this._opt("defaultRepo")) == null) {
          this.logger.error("Default Github repo not specified");
          return null;
        }
      }
      repo = repo.toLowerCase();
      if (repo.indexOf("/") !== -1) return repo;
      if ((user = this._opt("defaultUser")) == null) {
        this.logger.error("Default Github user not specified");
        return repo;
      }
      return "" + user + "/" + repo;
    };

    Github.prototype.request = function(verb, url, data, cb) {
      var args, oauth_token, req, task, url_api_base, _ref;
      var _this = this;
      if (cb == null) _ref = [data, null], cb = _ref[0], data = _ref[1];
      url_api_base = this._opt("apiRoot");
      if (url.slice(0, 4) !== "http") {
        if (url[0] !== "/") url = "/" + url;
        url = "" + url_api_base + url;
      }
      req = http.create(url).header("Accept", "application/vnd.github." + (this._opt("apiVersion")) + "+json");
      req = req.header("User-Agent", "GitHubot/" + version);
      oauth_token = this._opt("token");
      if (oauth_token != null) {
        req = req.header("Authorization", "token " + oauth_token);
      }
      args = [];
      if (data != null) args.push(JSON.stringify(data));
      if (verb === "DELETE" && !(data != null)) args.push("");
      task = {
        run: function(cb) {
          return req[verb.toLowerCase()].apply(req, args)(cb);
        }
      };
      return this.requestQueue.push(task, function(err, res, body) {
        var responseData, _ref2;
        if (err != null) {
          return _this._errorHandler({
            statusCode: res != null ? res.statusCode : void 0,
            body: res != null ? res.body : void 0,
            error: err
          });
        }
        try {
          if (body) responseData = JSON.parse(body);
        } catch (e) {
          return _this._errorHandler({
            statusCode: res.statusCode,
            body: body,
            error: "Could not parse response: " + body
          });
        }
        if ((200 <= (_ref2 = res.statusCode) && _ref2 < 300)) {
          return cb(responseData);
        } else {
          return _this._errorHandler({
            statusCode: res.statusCode,
            body: body,
            error: responseData.message
          });
        }
      });
    };

    Github.prototype.get = function(url, data, cb) {
      var _ref;
      if (cb == null) _ref = [data, null], cb = _ref[0], data = _ref[1];
      if (data != null) url += "?" + querystring.stringify(data);
      return this.request("GET", url, cb);
    };

    Github.prototype.post = function(url, data, cb) {
      return this.request("POST", url, data, cb);
    };

    Github.prototype["delete"] = function(url, cb) {
      return this.request("DELETE", url, null, cb);
    };

    Github.prototype.put = function(url, data, cb) {
      return this.request("PUT", url, data, cb);
    };

    Github.prototype.patch = function(url, data, cb) {
      return this.request("PATCH", url, data, cb);
    };

    Github.prototype.handleErrors = function(callback) {
      var _this = this;
      return this._errorHandler = function(response) {
        callback(response);
        return _this._loggerErrorHandler(response);
      };
    };

    Github.prototype._loggerErrorHandler = function(response) {
      var message;
      message = response.error;
      if (response.statusCode != null) {
        message = "" + response.statusCode + " " + message;
      }
      return this.logger.error(message);
    };

    Github.prototype._errorHandler = function(response) {
      return this._loggerErrorHandler(response);
    };

    Github.prototype.branches = require('./branches');

    Github.prototype.deployments = require('./deployments');

    Github.prototype._opt = function(optName) {
      var _ref, _ref2;
      if ((_ref = this.options) == null) this.options = {};
      return (_ref2 = this.options[optName]) != null ? _ref2 : this._optFromEnv(optName);
    };

    Github.prototype._optFromEnv = function(optName) {
      var _ref, _ref2, _ref3;
      switch (optName) {
        case "token":
          return process.env.HUBOT_GITHUB_TOKEN;
        case "concurrentRequests":
          return (_ref = process.env.HUBOT_CONCURRENT_REQUESTS) != null ? _ref : 20;
        case "defaultRepo":
          return process.env.HUBOT_GITHUB_REPO;
        case "defaultUser":
          return process.env.HUBOT_GITHUB_USER;
        case "apiRoot":
          return (_ref2 = process.env.HUBOT_GITHUB_API) != null ? _ref2 : "https://api.github.com";
        case "apiVersion":
          return (_ref3 = process.env.HUBOT_GITHUB_API_VERSION) != null ? _ref3 : "v3";
        default:
          return null;
      }
    };

    return Github;

  })();

  module.exports = github = function(robot, options) {
    if (options == null) options = {};
    return new Github(robot.logger, options);
  };

  _ref = Github.prototype;
  for (method in _ref) {
    func = _ref[method];
    github[method] = func;
  }

  github.logger = {
    error: function(msg) {
      var util;
      util = require("util");
      return util.error("ERROR: " + msg);
    },
    debug: function() {}
  };

  github.requestQueue = async.queue(function(task, cb) {
    return task.run(cb);
  }, (_ref2 = process.env.HUBOT_CONCURRENT_REQUESTS) != null ? _ref2 : 20);

}).call(this);
