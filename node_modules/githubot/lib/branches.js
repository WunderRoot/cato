(function() {
  var async;
  var __slice = Array.prototype.slice;

  async = require("async");

  module.exports = function(repo, cb) {
    var _this = this;
    if (cb != null) {
      return this.get("repos/" + (this.qualified_repo(repo)) + "/branches", cb);
    } else {
      return {
        create: function(branchName, opts, cb) {
          var _ref, _ref2;
          if (cb == null) _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
          if ((_ref2 = opts.from) == null) opts.from = "master";
          return _this.get("repos/" + (_this.qualified_repo(repo)) + "/git/refs/heads/" + opts.from, function(json) {
            var sha;
            sha = json.object.sha;
            return _this.post("repos/" + (_this.qualified_repo(repo)) + "/git/refs", {
              ref: "refs/heads/" + branchName,
              sha: sha
            }, function(data) {
              return cb({
                name: branchName,
                commit: {
                  sha: data.object.sha,
                  url: data.object.url
                }
              });
            });
          });
        },
        "delete": function() {
          var actions, branchName, branchNames, cb, _fn, _i, _j, _len;
          branchNames = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
          actions = [];
          _fn = function(branchName) {
            return actions.push(function(done) {
              return _this.request("DELETE", "repos/" + (_this.qualified_repo(repo)) + "/git/refs/heads/" + branchName, done);
            });
          };
          for (_j = 0, _len = branchNames.length; _j < _len; _j++) {
            branchName = branchNames[_j];
            _fn(branchName);
          }
          return async.parallel(actions, cb);
        },
        merge: function(head, opts, cb) {
          var body, _ref, _ref2, _ref3;
          if (cb == null) _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
          body = {
            base: (_ref2 = (_ref3 = opts.base) != null ? _ref3 : opts.into) != null ? _ref2 : "master",
            head: head
          };
          if (opts.message != null) body.commit_message = opts.message;
          return _this.post("repos/" + (_this.qualified_repo(repo)) + "/merges", body, function(data) {
            if (data == null) return _this.logger.error("Nothing to merge");
            return cb({
              sha: data.sha,
              message: data.commit.message,
              url: data.url
            });
          });
        }
      };
    }
  };

}).call(this);
